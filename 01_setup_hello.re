= 開発環境を作る
== コンパイラ・エミュレータ等をインストール
本書ではC言語と一部アセンブラを使用して開発を行います。そのため、最低限、「コンパイラ/アセンブラ(GCC)」と「エディタ(好きなものを)」があれば良いです。加えて、作成したバイナリを試すための「エミュレータ(QEMU)」や、ビルドルールを管理するために「make」等を適宜インストールします。

筆者の作業環境の都合上、開発環境構築はDebian(バージョン8 Jessie)で説明しますが、同じくパッケージ管理にAPTを使用するUbuntuでも同様に構築できると思います。

インストールするパッケージは以下の通りです。

 * build-essential
 ** GCCやmake等が含まれるパッケージ
 * qemu-system-x86
 ** 64ビットのx86CPUのエミュレータ
 * ovmf
 ** 仮想マシン向けUEFIファームウェア(後述)

以下のコマンドでインストールできます。

//cmd{
$ @<b>{sudo apt install build-essential qemu-system-x86 ovmf}
//}

Ubuntuにはovmfパッケージが無い様です。結局は"OVMF.fd"というファームウェアバイナリが欲しいだけなので、ovmfパッケージが無ければ以下からバイナリをダウンロードしてください。

 * @<href>{https://sourceforge.net/projects/edk2/files/OVMF/}
 ** 2018/01現在、"OVMF-X64-r15214.zip"がOVMF.fdを含む最新のアーカイブです

//note[OVMF(Open Virtual Machine Firmware)について]{
"ovmf"パッケージはQEMUに含まれていないUEFIファームウェアを追加するためにインストールしています。最近のPCではレガシーBIOSからUEFIへBIOSのファームウェア実装が変わっているのですが、QEMUにはレガシーBIOSしか含まれていないため、"OVMF(Open Virtual Machine Firmware)"という仮想マシン向けのUEFI仕様準拠のファームウェアバイナリをインストールしています。

UEFIについてはGoogle検索でもいろいろと情報が出てきます。本シリーズの前著でも「UEFIファームウェアを直接叩くプログラムを作る」本を出しており、PDF版は無料で公開していますので興味があれば見てもらえると嬉しいです(本書の「参考情報」にURLを記載しています)。
//}

== ブートローダーを用意
本書で作成するプログラムをメモリへロードし、そこへジャンプする「ブートローダー」は既に用意したものがあります。

以下のURLからブートローダー"poiboot"のアーカイブ"poiboot_20180422.zip"をダウンロードして展開しておいてください。

 * @<href>{http://yuma.ohgami.jp}

ブートローダーについて少し説明します。

PCは電源を入れるとレガシーBIOSやUEFIといったファームウェアが動作します。ファームウェアは、レガシーBIOSであれば起動ディスクの先頭512バイト(マスタブートレコード)を、UEFIであれば起動ディスク第1パーティションの特定のパスにある実行バイナリをメモリへロードし実行します。

ここで実行されるプログラムが一般的にブートローダーと呼ばれるものです。ブートローダーはファームウェアとやり取りして、その次に実行するプログラム(一般的には「カーネル」)をメモリへロードし、ファームウェアとのやり取りを終え@<fn>{why_exit_firmware}、メモリへロードしたプログラムの実行を開始します。
//footnote[why_exit_firmware][ファームウェア動作中はファームウェアが各種ハードウェアを管理しており、特定のメモリ領域が使えなかったりします。カーネル起動後はカーネル側でこれらのリソースを管理したいため、ファームウェアが動作できないモードへ移行します。]

本書は64ビットのx86 CPUの制御方法を紹介する本ですので、UEFIは終了した状態から始めるため、ブートローダーは上記の通り、既に用意したものを使って説明します。

なお、上記のpoibootは前著「フルスクラッチで作る!UEFIベアメタルプログラミング パート1/パート2」の内容に少し追加したものです。ブートローダーに興味があれば見てみてください(無料公開しているPDF版のURLを本書「参考情報」に記載しています)。また、前著から手を加えた部分は本書「付録」に記載しています。

== 実機で試す際は
「はじめに」でも記載しました通り、本書のサンプルを試す際、まずはQEMUで試すと良いと思います。

実機で試したい場合はUSBフラッシュメモリ等、PCの起動ディスクとして使えるストレージをご用意ください。

#@# 「UEFI + x86(64ビット)」なPCであれば動作すると思いますが、筆者の手持ちの都合上「Lenovo製ThinkPad E450」でしか確認していないため、他のPCでは動かないことがあるかも知れません。

#@# 主にブートローダーにて、PCに依存しそうな設定箇所は、本書「付録」に記載していますので、実機で動かない時はこちらを見てみてください。

== ブートローダー設定
本章の最後にブートローダーの設定を済ませます。といっても、やることは以下の2つです。

 1. OSが使用できるメモリ領域を確認
 2. 使用可能なメモリ領域の先頭アドレスを設定ファイルへ記載

なお、QEMUの場合、メモリ空間内のアドレスが変わることは無いと思いますので、以降の手順は飛ばしても構いません。

=== OSが使用できるメモリ領域を確認
まずは、OSがデータ等の配置に使用できるメモリ領域を確認します。0x0000000000000000から0xffffffffffffffffのアドレス空間のどのアドレスが何に対応しているかが記載された「メモリマップ」は、BIOS(UEFI)が持っています@<fn>{about_pa_memorymap}。そのため、ファームウェア側へメモリマップの問い合わせを行うブートローダーに相当するプログラムを書く必要があるのですが、UEFIの場合、「UEFIシェル」というシェルがあり、このシェル上でファームウェア側の各種パラメータを参照できますので、ここではUEFIシェルを使用します。
//footnote[about_pa_memorymap][厳密には「物理アドレス」に対応したメモリマップを持っています。CPUはMMU(メモリ管理ユニット)により変換された「仮想アドレス」で動作し、一般的なカーネルは仮想アドレスのメモリマップを何パターンも持っています。ただしUEFIの場合、ファームウェア側で「物理アドレス=仮想アドレス」となるようにMMUの設定を行ってくれます。本書では「物理アドレス=仮想アドレス」設定のまま使用するため特に仮想アドレスは意識しません。]

UEFIシェルのアーカイブを以下からダウンロードします。なお、UEFIファームウェアによってはUEFIシェルを内蔵している場合もありますので、その際はダウンロード不要です。

 * todo: UEFIシェルへのリンクを追記

ダウンロードしたアーカイブは展開してください。

展開後、UEFIファームウェアが見つけられるように、起動用ストレージ(USBフラッシュメモリ等)へ配置します。アーカイブを展開すると"uefi_shell.efi(todo:ファイル名要確認)"という名前のファイルがありますので起動用ストレージの@<list>{place_uefi_shell}の場所へ配置してください。

なお、UEFIファームウェアはFATあるいはGPT@<fn>{about_gpt}の第1パーティションを認識します。USBフラッシュメモリ等は購入時、FATパーティションが一つのみの状態であるため特に問題は無いかと思います。UEFI向けのGPTフォーマットの仕方は付録に記載しておりますので、必要であれば参照してください。
//footnote[about_gpt]["GUID Partition Table"と呼ばれるもので、UEFI向けに新たに作られたものです。]

//list[place_uefi_shell][UEFIシェルバイナリの配置]{
起動用ストレージ/
└── EFI/
    └─BOOT/
         └─ BOOTX64.EFI  ← uefi_shell.efiをリネームして配置
//}

UEFIファームウェアは起動ディスクに"EFI/BOOT/BOOTX64.EFI"というパスで

そして、PCのBIOS(UEFI)設定を変更し、作成した起動用ストレージからブートするとUEFIシェルが立ち上がり、以下のようにプロンプトが表示されます。

//cmd{
Shell>
//}

"memmap"というコマンドでメモリマップを確認できます。

//cmd{
Shell> @<b>{memmap}
todo: 結果を追記
//}

結果が1画面に収まらない場合、勝手にスクロールしてしまいますが、"PgUp"/"PgDn"キーで上下にスクロールできます。

"Available"と記載されている領域が使用可能なメモリ領域で、"Pages(todo: 要確認)"列に各領域のサイズが記載されています。サイズはページ数なので、ページサイズ(4KB)を掛けた値がバイト数になります。メモリ領域としてどのような領域を選ぶ必要があるかは次節で説明します。

なお、上記の結果はQEMUでOVMF使用時のものです。OVMFにはUEFIシェルが内蔵されているため、QEMUでは以下のコマンドでUEFIシェルを起動できます。

//cmd{
■ APTでovmfパッケージをインストールした場合
$ @<b>{qemu-system-x86_64 -m 4G -bios OVMF.fd}
■ OVMF.fdをダウンロードしてきた場合
$ @<b>{qemu-system-x86_64 -m 4G -bios OVMF.fdへのパス指定}
//}

QEMUに搭載メモリを4GBと認識させる"-m 4G"のオプションを付けている理由は本章最後のコラムで説明します。

=== 使用可能なメモリ領域の先頭アドレスを設定ファイルへ記載
ブートローダー"poiboot"は、起動用ストレージの第1階層(一番上位)に配置されている以下のファイルをメモリへロードします。

 * kernel.bin
 ** カーネルの実行バイナリ
 * fs.img (存在しなければスキップ)
 ** いくつかのファイルをまとめたイメージファイル

これらのファイルのロード先アドレスを設定するファイルが"poiboot.conf"で、poiboot.confへ記載する内容は以下の通りです。

 * 1行目: kernel.binのロード先アドレス(16進数16文字)
 * 2行目: fs.imgのロード先アドレス(16進数16文字)

前節のmemmapコマンドの結果の中で"Available"な領域を2つ選び、それぞれの先頭アドレスをpoiboot.confというテキストファイルに保存してください。

なお、それぞれの領域を選ぶ際は以下の条件を満たすものを選んでください。おそらくデフォルトの設定ファイルの値をそのまま使用すれば問題ないかと思います。

 * 1行目: kernel.binのロード先
 ** 先頭アドレスから1MB先をスタックのベースアドレスにしているため、サイズが1MB以上であること
 ** デフォルトの設定ファイルの値: 0000000000110000
 * 2行目: fs.imgのロード先
 ** 本書最後の方で1枚2MB弱の画像ファイルをいくつか配置するため、20MB以上はあると良い
 ** デフォルトの設定ファイルの値: 0000000100000000

===[column] QEMUの"-m 4G"オプションの理由(RAMがマップされるアドレスについて)
